package org.six3d.display {	import flash.events.Event;	import flash.geom.ColorTransform;	import flash.geom.Rectangle;	import flash.utils.getDefinitionByName;	import org.six3d.display.DisplayObjectContainer3D;	import org.six3d.typography.*;	import de.polygonal.ds.Iterator;		/**	 * @author Robert Sköld, bob@six3d.org	 */	public class Text3D extends DisplayObject3D {		public static const SCALE_FACTOR : int = 100;		protected var _glyphs : Array;		private var _typography : IType;		private var _text : String = "";		private var _size : Number = 10;		private var _color : uint = 0x000000;		private var _temp : String = "";		private var _loading : Boolean = false;		private var _multiline : Boolean = true;		private var _leading : Number = 0;		public function Text3D( name : String = null ) {			super( name );		}		public override function initialize() : void {			if( _temp ) {				text = _temp;			}		}		public function isTypeReady() : Boolean {			return typography != null && typography.initialized( );		}		public function get text() : String {			return isTypeReady( ) ? _text : _temp;		}		public function set text( value : String ) : void {			if( !scene ||  _loading ) {				// Waiting for addChild() or for the type to load				_temp = value;				return;			}			if( !isTypeReady( ) ) {				try {					typography = new ( getDefinitionByName( "org.six3d.typography.HelveticaMedium" ) as Class )( );				} catch( e : Error ) {					throw new Error( "No default typography defined" );					return;				}			}			if( !multiline ) {				// Strip new lines				value = value.replace( /\n/g , "" );			}			createGlyphs( value );			_text = value;			removeAdditionalGlyphs( );			placeGlyphs( );			askRendering( true );		}		private function createGlyphs( txt : String) : void {			for( var i : int = 0; i < txt.length ; i++) {				if( txt.charAt( i ) != _text.charAt( i ) ) {					addGlyphAt( i , txt.charAt( i ) );				}			}		}		private function addGlyphAt( index : int , glyph : String ) : void {			var shape : Shape3D = new Shape3D();			shape.addMotif( [ [ 'B', [ color , 1 ] ] ].concat( Motif.clone( typography.getMotif( glyph ) ) ).concat( [ [ 'E' ] ] ) );			shape.scaleX = size / SCALE_FACTOR;			shape.scaleY = size / SCALE_FACTOR;			if( typography is ILoadableType ) {				// Flip it if it's a svg type				shape.scaleY *= -1;			}			if( _glyphs[ index ] != null ) removeGlyph( index );			_glyphs.splice( index , 0 , shape ); 			// Insert into glyph array			addChild( shape );		}		private function removeAdditionalGlyphs() : void {			while( _glyphs.length > text.length ) {				removeGlyph( _glyphs.length - 1 );			}		}		private function removeGlyph( index : int ) : void {//			trace( "removing:" , _glyphs[ index ] + " - " + text.charAt( index ) );			removeChildByName( _glyphs[ index ].name );			_glyphs.splice( index , 1 );		}				private function removeGlyphs() : void {			if( _glyphs ) {				while( _glyphs.length ) {					removeGlyph( 0 );				}			}		}		private function placeGlyphs() : void {			var x : Number = 0;			var y : Number = 0;			for (var i : Number = 0; i < _glyphs.length ; i++) {				if (_glyphs[i].x != x ) _glyphs[i].x = x;				if (_glyphs[i].y != y ) _glyphs[i].y = y;				var w : Number = typography.getWidth( text.charAt( i ) , text.charAt( i + 1 ) ) * size / SCALE_FACTOR;				x += w;								// Add newline				if( multiline && /\n/.test( _text.charAt( i ) ) ) { 					x = 0;					y += ( typography.getHeight( ) * size / SCALE_FACTOR ) + leading;				}			}		}		/**		 * Returns a rectangle of a character		 * @param index (int) of the target character		 * @return Rectangle		 */		public function getCharBoundaries( index : int ) : Rectangle {			var glyph : Shape3D = _glyphs[ index - 1 ];			var width : Number = typography.getWidth( text.charAt( index - 1 ) ) * size / SCALE_FACTOR;			if( !isTypeReady( ) || !glyph ) return new Rectangle( );			return new Rectangle( glyph.x , glyph.y , width , typography.getHeight( ) ); 		}		public function set typography( type : IType ) : void {			if( type.initialized( ) ) {				_typography = type;				reinitText( _text );			} else {				if( type is ILoadableType ) {					_loading = true;					ILoadableType( type ).addEventListener( Event.COMPLETE , onTypeLoaded );					ILoadableType( type ).load( );				}			}		}		public function get typography() : IType {			return _typography;		}		private function onTypeLoaded( event : Event ) : void {			_loading = false;			typography = event.target as IType;			if( _temp ) text = _temp;		}		private function reinitText( value : String ) : void {			removeGlyphs();			_glyphs = new Array();			_text = "";			text = value;		}		public function get multiline() : Boolean {			return _multiline;		}		public function set multiline( value : Boolean) : void {			_multiline = value;		}		public function get leading() : Number {			return _leading;		}		public function set leading( value : Number) : void {			_leading = value;		}		public function get size() : Number {			return _size;		}		public function set size(value : Number) : void {			_size = value;			if( !isTypeReady( ) ) return;			resizeGlyphs( );			placeGlyphs( );			askRendering( true );		}		private function resizeGlyphs() : void {			var itr : Iterator = _children.getIterator();			while( itr.hasNext() ) {				var s : Shape3D = Shape3D( itr.data );				s.scaleX = s.scaleY = size / SCALE_FACTOR;				itr.next( );			}		}		public function get color() : uint {			return _color;		}		public function set color( value : uint ) : void {			_color = value;			if( !isTypeReady() ) return;			colorizeGlyphs();		}		private function colorizeGlyphs() : void {			var itr : Iterator = _children.getIterator();			while( itr.hasNext() ) {				var s : Shape3D = Shape3D( itr.next() );				var c : ColorTransform = s.sprite.transform.colorTransform;				c.color = _color;				s.sprite.transform.colorTransform = c;			}		}		public override function render() : void {			if( !visible && sprite.visible ) {				sprite.visible = false;			} else if( visible ) {				if( !sprite.visible ) {					sprite.visible = true;				}				if( _render ) {					getMatrices();					super.render();					_render = false;				}			}		}		public override function toString() : String {			return "[Text3D " + name + "]";		}	}}