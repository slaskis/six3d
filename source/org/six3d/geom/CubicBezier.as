package org.six3d.geom {	import flash.geom.Point;			/**	 * @author Robert SkÃ¶ld, bob@six3d.org	 */	public class CubicBezier {		private var _p1 : Point;		private var _p2 : Point;		private var _c1 : Point;		private var _c2 : Point;		public function CubicBezier( p1 : Point , c1 : Point , c2 : Point , p2 : Point ) {			_p1 = p1;			_c1 = c1;			_c2 = c2;			_p2 = p2;		}				public function get p1() : Point {			return _p1;		}		public function get p2() : Point {			return _p2;		}		public function get c1() : Point {			return _c1;		}		public function get c2() : Point {			return _c2;		}				/**		 * Approximates a cubic bezier with as many quadratic bezier segments (n) as required to achieve a specified tolerance		 * @param p (Number), point on curve, 0-1		 * @return (Point) on curve		 */		public function getPointOnCurve( p : Number ) : Point {			var pt : Point = new Point();						// Squared / Cubed			var sq : Number = p * p;			var cb : Number = sq * p;						// calculate the polynomial coefficients			var cx : Number = 3 * ( c1.x - p1.x );			var bx : Number = 3 * ( c2.x - c1.x ) - cx;			var ax : Number = p2.x - p1.x - cx - bx;			var cy : Number = 3 * ( c1.y - p1.y );			var by : Number = 3 * ( c2.y - c1.y ) - cy;			var ay : Number = p2.y - p1.y - cy - by;			pt.x = ( ax * cb ) + ( bx * sq ) + ( cx * p ) + p1.x;			pt.y = ( ay * cb ) + ( by * sq ) + ( cy * p ) + p1.y;						return pt;		}				/**		 * Finds the middle points of the Curve		 * @return Point		 */				public function middle() : Point {			return new Point( ( p1.x + p2.x ) / 2 , ( p1.y + p2.y ) / 2 );		}						/**		 * Finds the middle point between two points		 * @param pt1 (Point), first point		 * @param pt2 (Point), second point		 * @return Point		 */				public static function mid( pt1 : Point , pt2 : Point ) : Point {			return new Point( ( pt1.x + pt2.x ) / 2 , ( pt1.y + pt2.y ) / 2 );		}				/**		 * Finds the point of intersection of two lines		 * @param p1 (Point), start line 1		 * @param p2 (Point), end line 1		 * @param p3 (Point), start line 2		 * @param p4 (Point), end line 2		 * @return Point or null if no intersection was found		 */				public static function intersection( p1 : Point , p2 : Point , p3 : Point , p4 : Point) : Point {			var dx1 : Number = p2.x - p1.x;			var dx2 : Number = p3.x - p4.x;			if (!(dx1 || dx2)) {				return null;			}						var m1 : Number = ( p2.y - p1.y ) / dx1;			var m2 : Number = ( p3.y - p4.y ) / dx2;			if (!dx1) {				return new Point( p1.x , m2 * ( p1.x - p4.x ) + p4.y );			} else if (!dx2) {				return new Point( p4.x , m1 * ( p4.x - p1.x ) + p1.y );			}			var xInt : Number = (-m2 * p4.x + p4.y + m1 * p1.x - p1.y ) / (m1 - m2);			var yInt : Number = m1 * ( xInt - p1.x ) + p1.y;			return new Point( xInt , yInt );		}				/**		 * Splits a Cubic bezier curve in two bezier curves		 * @return an array with two CubicBezier 		 */		public function split() : Array {			var p01 : Point = mid( p1 , c1 );			var p12 : Point = mid( c1 , c2 );			var p23 : Point = mid( c2 , p2 );			var p02 : Point = mid( p01 , p12 );			var p13 : Point = mid( p12 , p23 );			var p03 : Point = mid( p02 , p13 );			var b1 : CubicBezier = new CubicBezier( p1 , p01 , p02 , p03 );			var b2 : CubicBezier = new CubicBezier( p03 , p13 , p23 , p2 );			return [ b1 , b2 ];		}				/**		 * Approximates a cubic bezier with as many quadratic bezier segments (n) as required to achieve a specified tolerance		 * @param tolerance (Number), low number = more accurate result		 * @param curves (Array), contains an array of QuadBezier for recursion		 * @return curves (Array), contains an array of QuadBeziers		 */		public function getQuadBeziers( tolerance : Number = 1 , curves : Array = null ) : Array {			if( !curves ) curves = new Array();			// find intersection between bezier arms			var s : Point = intersection( p1 , c1 , c2 , p2 );			if( !s ) return curves;			// find distance between the midpoints			var dx : Number = ( p1.x + p2.x + s.x * 4 - ( c1.x + c2.x) * 3) * .125;			var dy : Number = ( p1.y + p2.y + s.y * 4 - ( c1.y + c2.y) * 3) * .125;			// split curve if the quadratic isn't close enough			if ( dx * dx + dy * dy > tolerance ) {				var halves : Array = split();				var b0 : CubicBezier = halves[0]; 				var b1 : CubicBezier = halves[1];				// recursive call to subdivide curve				b0.getQuadBeziers( tolerance , curves );				b1.getQuadBeziers( tolerance , curves );			} else {				// end recursion by saving points				var control : Point = new Point( s.x , s.y );				curves.push( new QuadBezier( p1 , control , p2 ) );			}			return curves;		}				public function toString() : String {			return "[CubicBezier p1: " + p1 + ", c1: " + c1 + ", c2: " + c2 + ", p2: " + p2 + "]";		}	}}